{"id":"index.html","dependencies":[{"name":"./index.js","dynamic":true,"resolved":"C:\\Users\\O\\Desktop\\Projects\\Totaled\\index.js","parent":"C:\\Users\\O\\Desktop\\Projects\\Totaled\\index.html"},{"name":"_css_loader","parent":"C:\\Users\\O\\Desktop\\Projects\\Totaled\\index.html","resolved":"C:\\Users\\O\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\src\\builtins\\css-loader.js"},{"name":"C:\\Users\\O\\Desktop\\Projects\\Totaled\\package.json","includedInParent":true,"mtime":1597218913504}],"generated":{"html":"<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <style>body{\r\n        padding:0;\r\n        margin:0;\r\n        width: 100vw;\r\n        overflow-x: hidden;\r\n        height:100vh;\r\n      }\r\n\r\n      html, body {\r\n\r\n        overflow-x: hidden;\r\n      }</style>\r\n    <meta charset=\"UTF-8\">\r\n    <link href=\"https://fonts.googleapis.com/css2?family=Rochester&display=swap\" rel=\"stylesheet\">\r\n    <link href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@200;300;400;500;700;900&display=swap\" rel=\"stylesheet\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Totaled</title>\r\n\r\n</head>\r\n<body>\r\n    <the-header></the-header>\r\n    <main-container></main-container>\r\n</body>\r\n\r\n<script>function returnFirstName(full) {\n  function caps(word) {\n    return word.charAt(0).toUpperCase() + word.slice(1);\n  }\n\n  return caps(full.split('-')[0]);\n}</script>\r\n<script src=\"https://www.unpkg.com/dom-to-image@2.6.0/src/dom-to-image.js\"></script>\r\n<script class=\"dontHost\" src=\"http://source.app.localhost:8080/\"></script>\r\n\r\n\r\n\r\n<script class=\"dontHost\">function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n//to do: add meta support\n//I have two options, \n// to do add support for serverless\n// read update, read & write rules of every \n\n/*\r\nIf I remove handle parse then I can I do everything with serverless?\r\nI can just say ifPremiumUser(), YES I can do everything.\r\n*/\n//U.serverless['ifPremiumUser'] = function(user){}\nU.cloudFunctions['like'] = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n  var contentId, currentAction, writtenData;\n  return regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          contentId = arg.contentId;\n          _context.next = 3;\n          return U.query({\n            $find: {\n              on: 'actions',\n              where: {\n                contentId: contentId\n              }\n            }\n          });\n\n        case 3:\n          currentAction = _context.sent;\n\n          if (!currentAction[0]) {\n            _context.next = 10;\n            break;\n          }\n\n          _context.next = 7;\n          return U.query({\n            $delete: {\n              on: 'actions',\n              where: {\n                contentId: contentId\n              }\n            }\n          });\n\n        case 7:\n          return _context.abrupt(\"return\", 'unClicked');\n\n        case 10:\n          _context.next = 12;\n          return U.query({\n            $write: {\n              on: 'actions',\n              put: {\n                type: arg.type,\n                contentId: contentId\n              }\n            }\n          });\n\n        case 12:\n          writtenData = _context.sent;\n\n          if (!writtenData.error) {\n            _context.next = 15;\n            break;\n          }\n\n          return _context.abrupt(\"return\", writtenData);\n\n        case 15:\n          return _context.abrupt(\"return\", 'clicked');\n\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}));\n\nU.cloudFunctions['sendRecommendation'] = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(scrollHitCount) {\n    var memesToSee, followingPages, newMemesFromPagesUserFollow, lastLikedMemes, similarPeoples, recommendationBufferLimit, skip;\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            memesToSee = []; //--------------------New memes from pages user follows---------------------------------------------------------------\n\n            if (scrollHitCount) {\n              _context2.next = 10;\n              break;\n            }\n\n            _context2.next = 4;\n            return U.query({\n              $find: {\n                on: 'actions',\n                where: {\n                  type: 'pages',\n                  sender: '$user.id'\n                }\n              }\n            });\n\n          case 4:\n            followingPages = _context2.sent;\n            followingPages = followingPages.map(function (item) {\n              return item.contentId;\n            }); //this is how small amount of users first see a meme, to keep audience base low\n            // limit is 3, If meme gets received well it will be shown in the second phase wwhere limit is infinite\n\n            _context2.next = 8;\n            return U.query({\n              $find: {\n                on: 'memes',\n                where: {\n                  pageTitle: {\n                    $in: followingPages\n                  }\n                },\n                limit: 3\n              }\n            });\n\n          case 8:\n            newMemesFromPagesUserFollow = _context2.sent;\n            memesToSee = newMemesFromPagesUserFollow;\n\n          case 10:\n            _context2.next = 12;\n            return U.query({\n              $find: {\n                on: 'actions',\n                where: {\n                  type: 'memes',\n                  sender: '$user.id',\n                  limit: 5\n                }\n              }\n            });\n\n          case 12:\n            lastLikedMemes = _context2.sent;\n            lastLikedMemes = lastLikedMemes.map(function (item) {\n              return item.contentId;\n            });\n            _context2.next = 16;\n            return U.query({\n              $find: {\n                on: 'actions',\n                where: {\n                  type: 'memes',\n                  contentId: {\n                    $in: lastLikedMemes\n                  },\n                  limit: 2\n                }\n              }\n            });\n\n          case 16:\n            similarPeoples = _context2.sent;\n            similarPeoples = similarPeoples.map(function (item) {\n              return item.sender;\n            }); //problem: we are not finding the most similar people, just those people who most recently liked the posts user liked\n\n            /*\r\n                Algorithms to find the most similar people, find all the people about 1000 who also liked the things user liked\r\n              just increase the limmit of similarPeoples we extracted above\r\n                then find all 5 other things they liked recently (taste of people change very quickly)\r\n                put it into an array of objects object will have the last things user liked and userid\r\n                perform nearest neighbour algorithm or content filtering to find the most similar people\r\n                this can be also used to recommend friends\r\n                problem: to find 5 for 1000 people will be insane\r\n                or maybe we can use group for this\r\n                //add aggregate feature (obviously it will only run on serverside)\r\n              */\n            //scrollHitCount means no. of times scrollbar hits the bottom\n\n            if (!scrollHitCount) scrollHitCount = 0;\n            recommendationBufferLimit = 30;\n            skip = scrollHitCount * recommendationBufferLimit;\n            _context2.next = 23;\n            return U.query({\n              $find: {\n                on: 'actions',\n                where: {\n                  type: 'memes',\n                  sender: {\n                    $in: similarPeoples\n                  },\n                  contentId: {\n                    $nin: lastLikedMemes\n                  },\n                  limit: 30,\n                  skip: skip\n                }\n              }\n            });\n\n          case 23:\n            recommededMemes = _context2.sent;\n            //here we are finding memes similar peoples liked, except the last 3 memes user liked\n            recommededMemes.map(function (item) {\n              memesToSee.push(item.contentId);\n            });\n            return _context2.abrupt(\"return\", memesToSee);\n\n          case 26:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nU.bucket['profileImages'] = {\n  updatable: true,\n  findable: true,\n  writable: true\n};\nU.bucket['memeImages'] = {\n  updatable: true,\n  findable: true,\n  writable: true\n};\n\nfunction setTitle() {\n  return _setTitle.apply(this, arguments);\n} //remove default,  \n\n\nfunction _setTitle() {\n  _setTitle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n    var count;\n    return regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return U.query({\n              $count: {\n                on: 'pages',\n                where: {\n                  city: '$put.city',\n                  fullName: '$put.fullName'\n                }\n              }\n            });\n\n          case 2:\n            count = _context5.sent;\n            return _context5.abrupt(\"return\", \"\".concat(put.fullName.replace(' ', '-'), \"-\").concat(put.city, \"-\").concat(count));\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _setTitle.apply(this, arguments);\n}\n\nU.db['pages'] = {\n  schema: {\n    title: {\n      default: setTitle,\n      type: String,\n      required: true,\n      unique: true,\n      updatable: false\n    },\n    fullName: {\n      type: String,\n      required: true\n    },\n    city: {\n      type: String\n    },\n    DPlink: {\n      type: String\n    },\n    //display profile link\n    description: {\n      type: String,\n      required: true\n    },\n    type: String,\n    instagramHandle: {\n      type: String\n    },\n    author: {\n      default: '$user.id',\n      type: String,\n      updatable: false,\n      findable: false,\n      writable: false\n    }\n  },\n  updatable: true,\n  findable: true,\n  writable: true\n}; //if you want to do a specific write or read just don't use intermediate just call {$serverless:'ifPremiumUser($user)'}\n\nU.db['bioInfo'] = {\n  schema: {\n    pageTitle: {\n      type: String,\n      required: true\n    },\n    field: {\n      type: String,\n      required: true\n    },\n    contentType: {\n      type: String,\n      required: true\n    },\n    value: {\n      type: String,\n      required: true\n    },\n    author: {\n      default: '$user.id',\n      type: String,\n      updatable: false,\n      findable: false,\n      writable: false\n    }\n  },\n  updatable: true,\n  findable: true,\n  writable: true\n};\n\nvar findActionReceiver = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n    var whereQuery, data, receiver;\n    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            whereQuery = {\n              id: '$put.contentId'\n            };\n            if (put.type == 'pages') whereQuery = {\n              title: '$put.contentId'\n            };\n            _context3.next = 4;\n            return U.query({\n              $find: {\n                on: '$put.type',\n                where: whereQuery\n              }\n            });\n\n          case 4:\n            data = _context3.sent;\n\n            if (data[0]) {\n              _context3.next = 7;\n              break;\n            }\n\n            throw Error('author not found');\n\n          case 7:\n            receiver = data[0].author;\n            return _context3.abrupt(\"return\", receiver);\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function findActionReceiver() {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nU.db['actions'] = {\n  schema: {\n    contentId: {\n      type: String,\n      required: true\n    },\n    type: {\n      type: String,\n      required: true\n    },\n    sender: {\n      default: '$user.id',\n      type: String,\n      required: true,\n      updatable: false,\n      findable: false,\n      writable: false\n    },\n    receiver: {\n      default: findActionReceiver,\n      type: String,\n      required: true,\n      findable: false\n    },\n    createdAt: {\n      type: Date,\n      default: {\n        '$date': 'now'\n      }\n    }\n  },\n  updatable: true,\n  findable: true,\n  writable: true,\n  onWrite: function () {\n    var _onWrite = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n      var lastActions, response, content, preActionCreation, prePreActionCreation, newRank;\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              console.log('now ranking');\n\n              if (!(field.type !== 'memes')) {\n                _context4.next = 3;\n                break;\n              }\n\n              return _context4.abrupt(\"return\");\n\n            case 3:\n              _context4.next = 5;\n              return U.query({\n                '$find': {\n                  on: 'actions',\n                  where: {\n                    type: 'memes',\n                    contentId: field.contentId\n                  },\n                  sort: {\n                    by: 'createdAt',\n                    order: 'descending'\n                  }\n                }\n              });\n\n            case 5:\n              lastActions = _context4.sent;\n\n              if (!(lastActions.length > 2)) {\n                _context4.next = 19;\n                break;\n              }\n\n              _context4.next = 9;\n              return U.query({\n                '$find': {\n                  on: 'memes',\n                  where: {\n                    id: '$field.contentId'\n                  }\n                }\n              });\n\n            case 9:\n              content = _context4.sent;\n              preActionCreation = lastActions[0].createdAt;\n              prePreActionCreation = lastActions[1].createdAt;\n              newRank = 1 / (preActionCreation - prePreActionCreation);\n\n              if (content[0]) {\n                newRank = content[0].rank * newRank;\n              }\n\n              _context4.next = 16;\n              return U.query({\n                '$update': {\n                  on: 'memes',\n                  where: {\n                    id: '$field.contentId'\n                  },\n                  put: {\n                    rank: newRank\n                  }\n                }\n              });\n\n            case 16:\n              response = _context4.sent;\n              _context4.next = 22;\n              break;\n\n            case 19:\n              _context4.next = 21;\n              return U.query({\n                '$update': {\n                  on: 'memes',\n                  where: {\n                    id: '$field.contentId'\n                  },\n                  put: {\n                    rank: 1\n                  }\n                }\n              });\n\n            case 21:\n              response = _context4.sent;\n\n            case 22:\n              return _context4.abrupt(\"return\", response);\n\n            case 23:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    function onWrite() {\n      return _onWrite.apply(this, arguments);\n    }\n\n    return onWrite;\n  }()\n};\nU.db['memes'] = {\n  schema: {\n    pageTitle: {\n      type: String,\n      required: true\n    },\n    imageLink: {\n      type: String,\n      required: true\n    },\n    overlays: {\n      type: Array,\n      required: true\n    },\n    author: {\n      default: '$user.id',\n      type: String,\n      updatable: false,\n      findable: false,\n      writable: false\n    },\n    createdAt: {\n      type: Date,\n      default: {\n        $date: 'now'\n      },\n      required: true,\n      updatable: false,\n      findable: false,\n      writable: false\n    },\n    rank: {\n      type: Number,\n      updatable: false,\n      writable: false\n    }\n  },\n  updatable: false,\n  findable: true,\n  writable: true\n};\nU.db['buttons'] = {\n  schema: {\n    pageTitle: {\n      type: String,\n      required: true\n    },\n    buttonText: {\n      type: String,\n      required: true\n    },\n    contentType: {\n      type: String,\n      required: true\n    },\n    author: {\n      default: '$user.id',\n      type: String,\n      updatable: false,\n      findable: false,\n      writable: false\n    }\n  },\n  updatable: false,\n  findable: true,\n  writable: true\n}; //dont't allow public from reading registered_user_writer\n\nU.uploadStaticFiles(['addContentComponents/addBio.js', 'addContentComponents/addButton.js', 'addContentComponents/addMeme.js', 'images/header/logo.svg', 'images/header/flame.svg', 'aButton.js', 'addContent.js', 'addContentHeader.js', 'aMeme.js', 'aPage.js', 'aSearch.js', 'createPage.js', 'header.js', 'listOfMemes.js', 'mainContainer.js', 'profileContent.js', 'renderMeme.js', 'Ronchester-Regular.ttf', 'routal.js', 'userPages.js']);\nU.run('Totaled', {\n  local: true,\n  loginBeforeEntry: false,\n  host: false\n});</script>\r\n<script type=\"module\" src=\"/168726dbe96b3ce427e7fedce31bb0bc.js\"> </script>\r\n</html>"},"sourceMaps":null,"error":null,"hash":"86e1cbc4d83c70610e91c252c005f15e","cacheData":{"env":{}}}